#!/usr/bin/env node

var xor = require('lodash.xor'),
    difference = require('lodash.difference'),
    intersection = require('lodash.intersection'),
    glob = require('glob'),
    uniq = require('lodash.uniq'),
    every = require('lodash.every'),
    assign = require('lodash.assign'),
    chalk = require('chalk'),
    fs = require('fs'),
    optimist = require('optimist'),
    semver = require('semver'),
    exec = require('child_process').execSync,
    semverSatisfied = true,
    argv,
    packageJSON,
    shrinkwrapJSON,
    depDiff,
    depDiffCount,
    packageDeps,
    originalPackageDeps,
    shrinkwrapDeps,
    packageDevDeps,
    packagePeerDeps,
    packageOptionalDeps,
    foundOptionalDeps = [],
    foundPeerDeps = [],
    foundExtraneousDeps = [],
    ignoredDeps;

function loadJSON(path) {
  if (!fs.existsSync(path)) {
    process.stderr.write('Error "' + path + '" not found' + '\n');
    return null;
  }

  var json;

  try {
    json = require(path);
  } catch (e) {
    process.stderr.write('Error parsing JSON "' + path + '"\n');
  }

  return json || null;
}

function readKeys(object) {
  return Object.keys(object || {}) || [];
}

var npm_major_version = exec('npm -v').toString().match(/^(\d)\./)[1];

argv = optimist
  .usage('Ensure package.json and npm-shrinkwrap.json are in sync')
  .alias('d', 'dev')
  .alias('h', 'help')
  .alias('3', 'v3')
  .alias('v', 'verbose')
  .alias('V', 'version')
  .describe('3', 'Perform check taking npm3 flat structure into account.')
  .describe('d', 'Check devDependencies.')
  .describe('h', 'Show this help message.')
  .describe('v', 'Run in verbose mode')
  .describe('V', 'Outputs version')
  .argv;

if (argv.version) {
  process.stdout.write('npm-shrinwrap-check ' + loadJSON(__dirname + '/../package.json').version)
  process.exit(0);
}

if (argv.help) {
  optimist.showHelp();
  process.exit(0);
}

packageJSON = loadJSON(process.cwd() + '/package.json');
shrinkwrapJSON = loadJSON(process.cwd() + '/npm-shrinkwrap.json');

if (!packageJSON || !shrinkwrapJSON) {
  process.exit(1);
}

packageDeps = uniq([].concat(
  readKeys(packageJSON.dependencies),
  argv.dev ? readKeys(packageJSON.devDependencies) : []
));

originalPackageDeps = [].concat(packageDeps);

packageOptionalDeps = readKeys(packageJSON.optionalDependencies);
packagePeerDeps = readKeys(packageJSON.peerDependencies);

var thisNodeModulesPattern = new RegExp("^" + process.cwd() + "/node_modules");

if (argv.v3) {
  glob.sync(process.cwd() + "/**/node_modules/*/package.json", {follow: true}).forEach(function(pkgPath) {
    var pkg = loadJSON(pkgPath);
    var thisPackageDeps = readKeys(pkg.dependencies);
    var isValidPath = (
      every(
        pkgPath
          .replace(process.cwd(), '')
          .replace(/^\//, '')
          .split('/').map(function (segment, i) {
            return segment === 'node_modules' ? i % 2 === 0 : true
          })
      ) &&
      pkgPath.match(thisNodeModulesPattern)
    );

    if (!isValidPath) {
      return;
    }

    var thisPackageOptionalDeps = readKeys(pkg.optionalDependencies);
    var thisPackagePeerDeps = readKeys(pkg.peerDependencies);

    if (argv.v3) {
      packageDeps = packageDeps.concat(thisPackageDeps);

      if (!!pkg.name) {
        packageDeps = packageDeps.concat(pkg.name);
      }
    }

    foundOptionalDeps = foundOptionalDeps.concat(thisPackageOptionalDeps);
    foundPeerDeps = foundPeerDeps.concat(thisPackagePeerDeps);
  });

  var npm_ls;

  try {
    npm_ls = JSON.parse(exec('npm ls --json 2> /dev/null || true'));
  } catch (e) {
    process.stderr.write("Could not parse JSON returned by 'npm ls --json'");
    process.exit(1);
  }

  var topLevelExtraneousDeps = (
    (npm_ls.problems || [])
      .filter(function (problem) { return !!problem.match(/^extraneous:/) })
      .map(function (problem) { return problem.match(/^extraneous: ([^@]+)@/)[1] })
  )

  function belongsToExtraneous(node) {
    if (!node) {
      return false;
    }

    return (
      topLevelExtraneousDeps.indexOf(node.__name) >= 0 ||
      belongsToExtraneous(node.__parent)
    )
  }

  visitDeps(npm_ls, function (node) {
    if (belongsToExtraneous(node)) {
      foundExtraneousDeps.push(node.__name);
    }
  });

  foundExtraneousDeps = uniq(foundExtraneousDeps.concat(topLevelExtraneousDeps));
}

function visitDeps(node, visit, parent, key) {
  var decoratedNode = assign(
    {},
    node,
    {__parent: parent || null, __name: key || null}
  );

  visit(decoratedNode)

  if (node.dependencies) {
    readKeys(node.dependencies).forEach(function (depName) {
      var depNode = node.dependencies[depName];
      visitDeps(depNode, visit, decoratedNode, depName);
    });
  }
}

function walkDeps(node, acc) {
  acc = acc || [];

  if (node.dependencies) {
    readKeys(node.dependencies).forEach(function (depName) {
      var depNode = node.dependencies[depName];
      acc.push(depName);
      walkDeps(depNode, acc);
    });
  }

  return uniq(acc);
}

packageDeps = uniq(packageDeps);
shrinkwrapDeps = argv.v3 ?
                   walkDeps(shrinkwrapJSON) :
                   readKeys(shrinkwrapJSON.dependencies);

foundOptionalDeps = difference(
  uniq(foundOptionalDeps),
  [].concat(shrinkwrapDeps, originalPackageDeps)
);
foundPeerDeps = difference(
  uniq(foundPeerDeps),
  [].concat(shrinkwrapDeps, originalPackageDeps)
);
foundExtraneousDeps = difference(
  foundExtraneousDeps,
  [].concat(shrinkwrapDeps, originalPackageDeps)
);

ignoredDeps = uniq([].concat(
  foundOptionalDeps,
  foundPeerDeps,
  packagePeerDeps,
  packageOptionalDeps,
  foundExtraneousDeps
));

// Removing ignoreDeps
packageDeps = difference(packageDeps, ignoredDeps);
shrinkwrapDeps = difference(shrinkwrapDeps, ignoredDeps);

depDiff = xor(packageDeps, shrinkwrapDeps);
depDiffCount = Math.abs(depDiff.length);

var messages = [];

function log(level, message) {
  messages.push({level: level, message: message});
}

log.warn = log.bind(null, 'warn');
log.error = log.bind(null, 'error');
log.ok = log.bind(null, 'ok');

var logOutOfSync = (function () {
  var logged = false;

  return function () {
    if (!logged) {
      log.error('package.json and npm-shrinkwrap.json out of sync');
      logged = true;
    }
  }
})()

function printMessages(messages) {
  messages.forEach(function (message) {
    var level = message.level;
    var message = message.message;

    process[
      level == 'ok' ? 'stdout' : 'stderr'
    ].write(
      chalk[{
        ok: 'green',
        warn: 'yellow',
        error: 'red',
      }[level] || 'grey'](message) + '\n'

    );
  });
}

packageDeps.forEach(function(dependency) {
  var range = (packageJSON.dependencies && packageJSON.dependencies[dependency]) ||
        (argv.dev && packageJSON.devDependencies && packageJSON.devDependencies[dependency]);
  if (!range) return; // sub dependencies
  var version = (shrinkwrapJSON.dependencies[dependency] || {}).version;

  if (version && semver.validRange(range) && !semver.satisfies(version, range)) {
    semverSatisfied = false;
    logOutOfSync();
    log.warn(' * ' + dependency + '@' + version + ' in npm-shrinkwrap.json does not satisfy range ' + range + ' in package.json');
  }
});

if (depDiff.length) {
  var notInShrinkwrap,
      notInPackage;

  logOutOfSync();

  notInPackage = depDiff.filter(function(dependency) {
    return (packageDeps.indexOf(dependency) === -1);
  });

  notInShrinkwrap = depDiff.filter(function(dependency) {
    return (shrinkwrapDeps.indexOf(dependency) === -1);
  });

  notInShrinkwrap.map(function (dependency) {
    log.warn(' * ' + dependency + ' found in package.json but not in npm-shrinkwrap.json');
  });

  notInPackage.map(function (dependency) {
    log.warn(' * ' + dependency + ' found in npm-shrinkwrap.json but not in package.json');
  });
} else if(semverSatisfied) {
  log.ok('OK! package.json and npm-shrinkwrap.json are in sync');
}


if (argv.verbose) {
  [].concat(foundOptionalDeps, packageOptionalDeps).forEach(function (dependency) {
    log.warn('WARN: skipping check for optional dependency ' + dependency);
  });

  [].concat(foundPeerDeps, packagePeerDeps).forEach(function (dependency) {
    log.warn('WARN: skipping check for peer dependency ' + dependency);
  });

  foundExtraneousDeps.forEach(function (dependency) {
    log.warn('WARN: skipping check for extraneous dependency ' + dependency);
  });
}

if (npm_major_version === '3' && !argv.v3) {
  log.warn('WARN: Looks like you are using npm3, consider using -3 flag.');
}

printMessages(messages);

process.exit(+(depDiffCount !== 0 || !semverSatisfied));
